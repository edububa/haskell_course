\section{Sintaxis en funciones}
\subsection{Pattern matching}
\begin{frame}[fragile]
  \frametitle{Sintaxis en funciones}
  \framesubtitle{\emph{Pattern matching}}
  {\color{white}
    \begin{minted}[bgcolor=bg]{haskell}
   sayMe :: (Integral a) => a -> String
   sayMe 1 = "One!"
   sayMe 2 = "Two!"
   sayMe 3 = "Three!"
   sayMe 4 = "Four!"
   sayMe 5 = "Five!"
   sayMe x = "Not between 1 and 5"
    \end{minted}
  }

  {\color{white}
    \begin{minted}[bgcolor=bg]{text}
  Prelude> :l introduccion.hs
  [1 of 1] Compiling Main
  ( introduccion.hs, interpreted )
  Ok, modules loaded: Main.
  *Main> sayMe 5
  "Five!"
    \end{minted}
  }
\end{frame}

\subsection{Guards}
\begin{frame}[fragile]
  \frametitle{Sintaxis en funciones}
  \framesubtitle{\emph{Guards}}
  {\color{white}
    \begin{minted}[bgcolor=bg]{haskell}
   compare :: (Ord a) => a -> a -> Ordering
   a `compare` b
   | a > b     = GT
   | a == b    = EQ
   | otherwise = LT
    \end{minted}
  }
  {\color{white}
    \begin{minted}[bgcolor=bg]{text}
   Prelude> :l introduccion.hs
   [1 of 1] Compiling Main
   ( introduccion.hs, interpreted )
   Ok, modules loaded: Main.
   *Main> 1 `myCompare` 2
   LT
   *Main> 1 `myCompare` 0.5
   GT
    \end{minted}
  }
\end{frame}

\subsection{where}
\begin{frame}[fragile]
  \frametitle{Sintaxis en funciones}
  \framesubtitle{\emph{where}}
  {\color{white}
    \begin{minted}[bgcolor=bg]{haskell}
  initials :: String -> String -> String
  initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
  where (f:_) = firstname
  (l:_) = lastname
    \end{minted}
  }
\end{frame}
\subsection{let}
\begin{frame}[fragile]
  \frametitle{Sintaxis en funciones}
  \framesubtitle{\emph{let}}
  {\color{white}
    \begin{minted}[bgcolor=bg]{haskell}
  cylinder :: (RealFloat a) => a -> a -> a
  cylinder r h =
  let sideArea = 2 * pi * r * h
  topArea = pi * r ^2
  in  sideArea + 2 * topArea
\end{minted}
}
\end{frame}
\subsection{Case Expressions}
\begin{frame}[fragile]
  \frametitle{Sintaxis en funciones}
  \framesubtitle{\emph{Case Expressions}}
  {\color{white}
  \begin{minted}[bgcolor=bg]{haskell}
  describeList :: [a] -> String
  describeList xs = "The list is " ++
  case xs of [] -> "empty."
  [x] -> "a singleton list."
  xs -> "a longer list."
\end{minted}
}
\end{frame}